<!DOCTYPE html>
<html>
  <head>
    <title>DEMO</title>
  </head>
  <body>
    <div id="container"> 
    </div>
    
    <script>
    console.log('*******************************')
    /**
 1、不同的作用:
    Loader直译为"加载器"。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，
    如果想将其他文件也打包的话，就会用到 loader。所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。

    Plugin 直译为"插件"。Plugin 可以扩展 webpack 的功能，让webpack具有更多的灵活性。在Webpack运行的生命周期中会广播出许多事件，
    Plugin可以监听这些事件，在合适的时机通过Webpack提供的API改变输出结果。
  
  2、不同的用法:
    Loader在 module.rules中配置，也就是说它作为模块的解析规则而存在。 
    类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件(test)，使用什么加载(loader)和使用的参数(options)
    
    Plugin在 plugins中单独配置。类型为数组，每一项是一个plugin 的实例，参数都通过构造函数传入。
     */

    /*
    
    https://blog.csdn.net/weixin_44475093/article/details/116311515

    Load和Plugin
    一、区别
    loader:
    loader是文件加载器,能够加载资源文件,并对这些文件进行一些处理,例如编译、压缩等,最后一起打包到指定的文件中;
    
    plugin
    plugin赋予webpack各种灵活的功能,例如打包优化、资源管理、环境变量注入等,目的是解决loader无法实现的其他事情.

    二、运行时机
    1、loader运行在打包文件之前;
    2、plugins在整个编译周期起作用;

    三、编写loader
    1、loader的本质是函数,函数中的this作为上下文被webpack填充;
    2、函数中this是由webpack提供的对象,能获取当前loader所需要的各种信息;
    3、函数中有异步操作或同步操作,异步操作通过this.callback返回,返回值要求为string或Buffer
    4、loader的过程中,保持功能单一,避免做多种功能;
    
    四、编写plugin
    1、由于webpack基于发布订阅模式,在运行的生命周期中会广播出许多事件,插件通过监听事件,就可以在特定的阶段执行自己的插件任务;
    2、插件必须是一个函数或者是一个包含apply方法的对象,这样才能访问compiler实例;
    3、传给每个插件的compiler和compilation对象都是同一个引用;
    4、异步的事件需要在插件完完任务时调用回调函数通知webpack进入到下一个流程
    5、在emit事件发生时,代表源文件的转换和组装已经完成,可以读取最终输出的资源、代码块、模块及其依赖


    */
     
    </script>
  </body>
</html>
